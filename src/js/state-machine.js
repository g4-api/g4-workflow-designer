/* global setTimeout */

/**
 * Generates a unique identifier (UID) as a hexadecimal string.
 *
 * @returns {string} A unique identifier generated by combining a random number and converting it to a hexadecimal string.
 */
function uid() {
	return Math.ceil(Math.random() * 10 ** 16).toString(16);
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
class StateMachine {
	isInterrupted = false;

	constructor(definition, speed, handler) {
		this.definition = definition;
		this.speed = speed;
		this.handler = handler;
		this.data = {};
		this.callstack = [
			{
				sequence: this.definition.sequence,
				index: 0,
				unwind: null
			}
		];
		this.isRunning = false;
	}

	executeStep(step) {
		this.handler.executeStep(step, this.data);
	}

	unwindStack() {
		this.callstack.pop();
	}

	executeIfStep(step) {
		const value = this.handler.executeIf(step, this.data);
		const branchName = value ? 'true' : 'false';

		this.callstack.push({
			sequence: step.branches[branchName],
			index: 0,
			unwind: this.unwindStack.bind(this)
		});
	}

	executeLoopStep(step) {
		this.handler.initLoopStep(step, this.data);

		const program = {
			sequence: step.sequence,
			index: 0,
			unwind: () => {
				if (this.handler.canReplyLoopStep(step, this.data)) {
					program.index = 0;
				} else {
					this.unwindStack();
				}
			}
		};
		this.callstack.push(program);
	}

	execute() {
		if (this.isInterrupted) {
			this.handler.onInterrupted();
			return;
		}

		const depth = this.callstack.length - 1;
		const program = this.callstack[depth];

		if (program.sequence.length === program.index) {
			if (depth > 0) {
				program.unwind();
				this.execute();
			} else {
				this.isRunning = false;
				this.handler?.onFinished(this.data);
			}
			return;
		}

		const step = program.sequence[program.index];
		program.index++;

		if (this.handler.beforeStepExecution) {
			this.handler.beforeStepExecution(step, this.data);
		}

		switch (step.type) {
			case 'if':
				this.executeIfStep(step);
				break;
			case 'loop':
				this.executeLoopStep(step);
				break;
			default:
				this.executeStep(step);
				break;
		}

		if (this.handler.onStepExecuted) {
			this.handler.onStepExecuted(step, this.data);
		}
		setTimeout(this.execute.bind(this), this.speed);
	}

	start() {
		if (this.isRunning) {
			throw new Error('Already running');
		}
		this.isRunning = true;
		this.callstack[0].index = 0;
		this.execute();
	}

	interrupt() {
		if (!this.isRunning) {
			throw new Error('Not running');
		}
		this.isInterrupted = true;
	}
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
class StateMachineSteps {
	/**
	 * Creates a new G4 container object for use in a workflow.
	 *
	 * @param {string} name - The name of the container.
	 * @param {string} type - The type of the container (e.g., "stage", "job").
	 * @param {Object} properties - An object containing properties for the container.
	 * @param {Array} steps - An array of steps or sub-containers to include in the container's sequence.
	 * @returns {Object} A new container object with a unique ID and specified properties.
	 */
	static newG4Container(name, type, properties, steps) {
		return {
			id: uid(),                  // Generate a unique identifier for the container.
			componentType: 'container', // Specify the component type as "container".
			type,                       // The type of the container (e.g., stage, job).
			name,                       // The name of the container.
			properties,                 // Properties specific to the container.
			sequence: steps || []       // The sequence of steps or sub-containers; defaults to an empty array.
		};
	}

	/**
	 * Creates a new G4 step based on the provided manifest.
	 *
	 * @param {Object} manifest - The manifest object containing properties and parameters.
	 * @returns {Object} The newly created G4 step object.
	 */
	static newG4Step(manifest) {
		// Function to convert PascalCase to space-separated words
		const convertPascalToSpaceCase = str => str.replace(/([A-Z])/g, ' $1').trim();

		// Creates a new bridge object from a G4 parameter object.
		const newBridgeObject = (g4ParameterObject) => {
			let bridgeObject = {
				description: g4ParameterObject.description.join('\n'),  // Set summary
				name: convertPascalToSpaceCase(g4ParameterObject.name), // Convert name to space case
				required: g4ParameterObject.mandatory || false,         // Set required flag
				type: g4ParameterObject.type || 'String',               // Set type or default to 'String'
				value: g4ParameterObject.default || '',                 // Set default value or empty string
				optionsList: g4ParameterObject.values || []             // Set options or default to an empty array
			};

			// TODO: Consider to remove this condition
			if(bridgeObject.type.toUpperCase() === 'STRING' || bridgeObject.type.toUpperCase() === 'ANY') {
				bridgeObject.multiLine = false;
			}

			// Return the bridge object
			return bridgeObject;
		}

		// Initialize properties and parameters objects
		const properties = {};
		const parameters = {};

		// Process each property in manifest.properties
		if (manifest.properties) {
			for (const property of manifest.properties) {
				properties[property.name] = newBridgeObject(property);
			}
		}

		// Process each parameter in manifest.parameters
		if (manifest.parameters) {
			for (const parameter of manifest.parameters) {
				parameters[parameter.name] = newBridgeObject(parameter);
			}
		}

		// Check if the manifest has categories and determine if it is a condition or loop
		const categories = manifest.categories ? manifest.categories.join("|").toUpperCase() : "";
		let isCondition = categories.includes('CONDITION');
		let isLoop = categories.includes('LOOP');
		let isContainer = categories.includes('CONTAINER');

		// Initialize the new G4 step object
		let step = {
			componentType: "task",
		};

		// Check if the manifest is a condition and initialize the branches object
		if (isCondition) {
			step.componentType = 'switch';
			step.type = 'if';
			step.branches = {
				true: [],
				false: []
			};
		}

		// Check if the manifest is a loop and initialize the sequence array
		if (isLoop) {
			step.componentType = 'container';
			step.type = 'loop';
			step.sequence = [];
		}

		// Check if the manifest is a loop and initialize the sequence array
		if (isContainer) {
			step.componentType = 'container';
			step.name = "Actions Group";
			step.type = 'container';
			step.sequence = [];
		}

		// Set the remaining properties of the new G4 step object
		step.categories = manifest.categories ? manifest.categories.join("|").toUpperCase() : "";
		step.description = manifest.summary ? manifest.summary.join('\n') : 'TBD';
		step.id = uid();
		step.name = step.name === "Actions Group" ? step.name : convertPascalToSpaceCase(manifest.key);
		step.parameters = parameters;
		step.pluginName = manifest.key;
		step.pluginType = manifest.pluginType;
		step.properties = properties;

		// Return the new G4 step object
		return step;
	}
}

// Client for sending requests to the G4 API.
class G4Client {
	/**
	 * Creates an instance of G4Client.
	 * @param {string} baseUrl - The base URL for the G4 API.
	 */
	constructor(baseUrl = "http://localhost:9944/api/v4/g4") {
		// The base URL for the API.
		this.baseUrl = baseUrl;

		// The URL endpoint to fetch plugin manifests.
		this.manifestsUrl = `${this.baseUrl}/integration/manifests`;

		// The URL endpoint for the cache (if needed for future use).
		this.cacheUrl = `${this.baseUrl}/integration/cache`;

		// An in-memory cache to store fetched manifests.
		this.manifests = [];
	}

	/**
	 * Fetches the G4 cache from the API.
	 *
	 * @async
	 * @returns {Promise<Object>} A promise that resolves to the cached data retrieved from the API.
	 * @throws {Error} Throws an error if the network request fails or the response is not OK.
	 */
	async getCache() {
		try {
			// Fetch the cache data from the API using the cacheUrl endpoint.
			const response = await fetch(this.cacheUrl);

			// Check if the response status indicates success (HTTP 200-299).
			if (!response.ok) {
				throw new Error(`Network response was not ok: ${response.statusText}`);
			}

			// Parse the JSON data from the response.
			const data = await response.json();

			// Return the parsed cache data.
			return data;
		} catch (error) {
			// Log the error to the console for debugging.
			console.error('Failed to fetch G4 cache:', error);

			// Rethrow the error to ensure the caller is aware of the failure.
			throw new Error(error);
		}
	}

	/**
	 * Retrieves and organizes plugin manifests into groups based on their categories and scopes.
	 *
	 * @async
	 * @returns {Promise<Object>} A promise that resolves to an object containing grouped manifests.
	 * Each group is keyed by category (and optionally scope) with its corresponding manifests.
	 */
	async getGroups() {
		// Function to convert PascalCase to space-separated words.
		const convertPascalToSpaceCase = (str) => str.replace(/([A-Z])/g, ' $1').trim();

		// Fetch the manifests using the existing method.
		const manifests = await this.getManifests();

		// Initialize an empty object to store the groups.
		const groups = {};

		// Iterate through each manifest in the manifests object.
		for (const manifest of Object.values(manifests)) {
			// Ensure the manifest has a 'scopes' array.
			manifest.scopes = manifest.scopes || [];

			// Determine if the manifest has a scope that includes 'ANY' (case-insensitive).
			const isAnyScope = manifest.scopes.some(scope => scope.toUpperCase() === 'ANY') || manifest.scopes.length === 0;

			// Retrieve the categories array or use an empty array if it's undefined.
			const categories = manifest.categories || [];

			// If the manifest has 'ANY' scope, add it to each of its categories.
			if (isAnyScope) {
				for (const category of categories) {
					// Convert the category name to a space-separated string.
					const categoryName = convertPascalToSpaceCase(category);

					// Ensure the group exists for this category.
					groups[categoryName] = groups[categoryName] || { name: categoryName, manifests: [] };

					// Add the manifest to the category's group.
					groups[categoryName].manifests.push(manifest);
				}

				// Skip processing other scopes since 'ANY' covers all.
				continue;
			}

			// If no 'ANY' scope, iterate through each category and scope.
			for (const category of categories) {
				for (const scope of manifest.scopes) {
					// Create a combined category name (e.g., "Category (Scope)").
					const categoryName = `${convertPascalToSpaceCase(category)} (${convertPascalToSpaceCase(scope)})`;

					// Ensure the group exists for this combined category and scope.
					groups[categoryName] = groups[categoryName] || { name: categoryName, manifests: [] };

					// Add the manifest to the combined group's manifests.
					groups[categoryName].manifests.push(manifest);
				}
			}
		}

		// Return the organized groups.
		return groups;
	}

	/**
	 * Fetches and returns G4 manifests of type 'Action'.
	 * Caches the manifests after the first fetch to avoid redundant network requests.
	 * 
	 * @returns {Promise<Object>} A promise that resolves to the manifests object.
	 * @throws Will throw an error if the network request fails.
	 */
	async getManifests() {
		// If manifests are already cached, return them directly.
		if (this.manifests.length > 0) {
			return this.manifests;
		}

		try {
			// Fetch the plugin manifests from the API.
			const response = await fetch(this.manifestsUrl);

			// Check if the response status is OK (HTTP 200-299).
			if (!response.ok) {
				throw new Error(`Network response was not ok: ${response.statusText}`);
			}

			// Parse the JSON response.
			const data = await response.json();

			// Filter only the plugins of type 'Action' and organize them into a dictionary by `key`.
			this.manifests = data
				.filter(item => item.pluginType === 'Action') // Include only 'Action' type plugins.
				.reduce((cache, manifest) => {
					// Use the `key` field of the manifest as the dictionary key.
					cache[manifest.key] = manifest;
					return cache;
				}, {});

			return this.manifests; // Return the cached manifests.
		} catch (error) {
			// Log the error for debugging and rethrow it.
			console.error('Failed to fetch G4 plugins:', error);
			throw new Error(error);
		}
	}
}
