/* global setTimeout */

/**
 * Generates a unique identifier (UID) as a hexadecimal string.
 *
 * @returns {string} A unique identifier generated by combining a random number and converting it to a hexadecimal string.
 */
function uid() {
	return Math.ceil(Math.random() * 10 ** 16).toString(16);
}

/**
 * Determines whether a given value is an object.
 *
 * This function checks if the provided value is an object, which includes
 * objects, arrays, and functions. It explicitly excludes `null` and all
 * primitive types such as boolean, number, string, symbol, bigint, and undefined.
 *
 * @param {*} value - The value to be checked.
 * @returns {boolean} - Returns `true` if the value is an object, `false` if it's a primitive type.
 *
 * @example
 * assertObject({});            // returns true
 * assertObject([1, 2, 3]);     // returns true
 * assertObject(function() {}); // returns true
 * assertObject('Hello');       // returns false
 * assertObject(42);            // returns false
 * assertObject(true);          // returns false
 * assertObject(null);          // returns false
 * assertObject(undefined);     // returns false
 */
function assertObject(value) {
	// Exclude `null` since `typeof null` returns 'object', but it's a primitive.
	if (value === null) {
		return false;
	}

	// Check if the type of the value is 'object' or 'function'.
	// In JavaScript, functions are considered objects.
	return (typeof value === 'object' || typeof value === 'function');
}

/**
 * Converts a given string to camelCase.
 *
 * The function processes the input string by:
 * 1. Removing any non-alphanumeric separators (e.g., spaces, dashes, underscores).
 * 2. Capitalizing the first letter of each word except the first one.
 * 3. Ensuring the first character of the resulting string is in lowercase.
 *
 * @param {string} str - The input string to be converted to camelCase.
 * @returns {string} - The camelCase version of the input string. Returns 'N/A' if the input is falsy.
 *
 * @example
 * convertToCamelCase("Hello World"); // "helloWorld"
 * convertToCamelCase("convert_to_camel_case"); // "convertToCamelCase"
 * convertToCamelCase("Convert-This String"); // "convertThisString"
 * convertToCamelCase("alreadyCamelCase"); // "alreadyCamelCase"
 * convertToCamelCase(""); // "N/A"
 */
function convertToCamelCase(str) {
	// If the input string is falsy (e.g., null, undefined, empty), return 'N/A'.
	if (!str) {
		return 'N/A';
	}

	// Step 1: Replace any non-alphanumeric characters followed by a character with the uppercase of that character.
	// This removes separators and capitalizes the following letter.
	const camelCased = str.replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase());

	// Step 2: Convert the first character to lowercase to adhere to camelCase conventions.
	return camelCased.charAt(0).toLowerCase() + camelCased.slice(1);
}

/**
 * Converts a PascalCase string to a space-separated string.
 *
 * @param {string} str - The PascalCase string to convert.
 * @returns {string} - The converted space-separated string.
 */
function convertPascalToSpaceCase(str) {
	return str ? str.replace(/([A-Z])/g, ' $1').trim() : 'N/A';
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
class StateMachine {
	isInterrupted = false;

	/**
	 * Handler for managing a simple for-loop mechanism within automation steps.
	 *
	 * The `forLoopHandler` object provides two primary methods:
	 * 1. `initialize` - Sets up the initial loop counter based on the provided argument.
	 * 2. `assert` - Determines whether the loop should continue by decrementing and checking the loop counter.
	 *
	 * @typedef {Object} ForLoopHandler
	 * @property {Function} assert      - Checks if the loop should continue based on the current index.
	 * @property {Function} initialize  - Initializes the loop index based on the provided argument.
	 *
	 * @example
	 * const options = {
	 *     step: {
	 *         properties: {
	 *             'Argument': { value: '5' }
	 *         }
	 *     },
	 *     data: {}
	 * };
	 *
	 * // Initialize the loop index
	 * forLoopHandler.initialize(options);
	 *
	 * // Continue looping while assert returns true
	 * while (forLoopHandler.assert(options)) {
	 *     // Loop body logic here
	 * }
	 */
	static forLoopHandler = {
		/**
		 * Determines whether the loop should continue by decrementing the index and checking its value.
		 *
		 * This method decrements the `index` stored in `options.data` and returns `true` if the new value
		 * is greater than or equal to zero, indicating that the loop should continue. If the `index` becomes
		 * negative, it returns `false`, signaling the end of the loop.
		 *
		 * @param {Object} options      - The options object containing loop data and step information.
		 * @param {Object} options.data - An object to store loop-related data, including the `index`.
		 *
		 * @returns {boolean} `true` if the loop should continue; otherwise, `false`.
		 *
		 * @example
		 * // Assuming options.data.index is initially 3
		 * const shouldContinue = forLoopHandler.assert(options); // Decrements index to 2, returns true
		 * console.log(options.data.index); // Outputs: 2
		 */
		assert: (options) => {
			// Decrement the 'index' in options.data and check if it's still non-negative
			return --options.data[options.step.id]['index'] > 0;
		},

		/**
		 * Initializes the loop index based on the provided step argument.
		 *
		 * This method retrieves the 'Argument' property from the step's properties. If the argument is a valid
		 * number, it sets the `index` in `options.data` to that number. Otherwise, it defaults the `index` to 0.
		 *
		 * @param {Object} options - The options object containing step information and data storage.
		 * @param {Object} options.step - The step object containing properties used for initialization.
		 * @param {Object} options.step.properties - An object holding various properties of the step.
		 * @param {Object} options.step.properties.Argument - The 'Argument' property used to determine the loop count.
		 * @param {any}    options.step.properties.Argument.value - The value of the 'Argument' property, expected to be a number or numeric string.
		 * @param {Object} options.data - An object to store loop-related data, including the `index`.
		 *
		 * @returns {void}
		 *
		 * @example
		 * const options = {
		 *     step: {
		 *         properties: {
		 *             'Argument': { value: '5' }
		 *         }
		 *     },
		 *     data: {}
		 * };
		 *
		 * forLoopHandler.initialize(options);
		 * console.log(options.data.index); // Outputs: 5
		 */
		initialize: (options) => {
			// Retrieve the 'Argument' value from the step properties
			const argument = options.step.properties['argument'].value;

			// Check if the argument is a valid integer using a regular expression
			const isNumber = `${argument}`.match(/^\d+$/);

			// Parse the argument to an integer if it's a number; otherwise, default to 0
			const index = isNumber ? parseInt(argument, 10) : 0;

			// Initialize the loop index in options.data with the parsed value
			options.data[options.step.id] = options.data[options.step.id] || {};

			// Store the initialized index in options.data for loop tracking
			options.data[options.step.id]['index'] = index
		}
	};

	/**
	 * Provides handler methods (`assert` and `initialize`) for controlling while-loop behavior
	 * in a sequential workflow, using plugin assertions to determine looping conditions.
	 */
	static whileLoopHandler = {
		/**
		 * Asserts a condition to determine if the loop should continue.
		 *
		 * 1. Converts the step to a rule using `client.convertToRule`.
		 * 2. Overrides the plugin name to `"Assert"` (necessary when running an "If" step
		 *    in a sequential workflow designer).
		 * 3. Invokes the step via `StateMachine.invokeStep` and waits for the result.
		 * 4. Finds the relevant plugin and asserts it to decide the loop's continuation.
		 * 5. Returns the assertion result (true/false).
		 *
		 * @async
		 * @function
		 * @name assert
		 * @memberof whileLoopHandler
		 * @param {Object} options            - The options object used for asserting loop conditions.
		 * @param {Object} options.client     - A reference to the G4 client or automation service client.
		 * @param {Object} options.step       - The current step object being processed.
		 * @param {Object} options.automation - The overall automation object/context.
		 * @param {Object} options.session    - The current session object for tracking state.
		 * @param {Object} options.data       - A generic data object to store/retrieve arbitrary data between steps.
		 *
		 * @returns {Promise<boolean>} A promise that resolves to a boolean indicating if the loop should continue.
		 */
		assert: async (options) => {
			// Convert the step to a rule so it can be invoked in the automation engine.
			const rule = options.client.convertToRule(options.step);

			// Override the plugin name to "Assert" for the "If" step. This is necessary to ensure
			// the correct plugin is invoked under the sequential automation specifically for "If" logic.
			rule.pluginName = "Assert";

			// Prepare the options object for invoking the step.
			const invokeOptions = {
				automation: options.automation,
				rule: rule,
				session: options.session,
				step: options.step
			};

			// Invoke the step asynchronously and wait for the result.
			const response = await StateMachine.invokeStep(options.client, invokeOptions);

			// Locate the plugin in the automation result using the step ID.
			const plugin = options.client.findPlugin(options.step.id, response.automationResult);

			// Assert the plugin to determine if the loop should continue.
			const assertion = options.client.assertPlugin(plugin);

			// Update the session with any new data from the response.
			options.session = response.session;

			// Store the assertion result for subsequent steps.
			options.data['assertion'] = assertion;

			// Return the assertion result to decide loop continuation (true/false).
			return assertion;
		},

		/**
		 * Initializes the while loop by performing an initial "Assert" step, without returning
		 * the assertion. This sets up the conditions and updates the session for subsequent loop checks.
		 *
		 * 1. Converts the step to a rule using `client.convertToRule`.
		 * 2. Overrides the plugin name to `"Assert"` (necessary when running an "If" step
		 *    in a sequential workflow designer).
		 * 3. Invokes the step via `StateMachine.invokeStep` and waits for the result.
		 * 4. Locates the plugin in the automation result and asserts it, storing that result in `options.data`.
		 *
		 * @async
		 * @function
		 * @name initialize
		 * @memberof whileLoopHandler
		 * @param {Object} options            - The options object used for initializing loop conditions.
		 * @param {Object} options.client     - A reference to the G4 client or automation service client.
		 * @param {Object} options.step       - The current step object being processed.
		 * @param {Object} options.automation - The overall automation object/context.
		 * @param {Object} options.session    - The current session object for tracking state.
		 * @param {Object} options.data       - A generic data object to store/retrieve arbitrary data between steps.
		 *
		 * @returns {Promise<void>} A promise that resolves when initialization is complete.
		 */
		initialize: async (options) => {
			// Convert the step to a rule so it can be invoked in the automation engine.
			const rule = options.client.convertToRule(options.step);

			// Override the plugin name to "Assert" for the "If" step. This is necessary to ensure
			// the correct plugin is invoked under the sequential automation specifically for "If" logic.
			rule.pluginName = "Assert";

			// Prepare the options object for invoking the step.
			const invokeOptions = {
				automation: options.automation,
				rule: rule,
				session: options.session,
				step: options.step
			};

			// Invoke the step asynchronously and wait for the result.
			const response = await StateMachine.invokeStep(options.client, invokeOptions);

			// Locate the plugin in the automation result using the step ID.
			const plugin = options.client.findPlugin(options.step.id, response.automationResult);

			// Update the session with any new data from the response.
			options.session = response.session;

			// Assert the plugin to determine if the loop should continue. The result is stored, but not returned here.
			options.data['assertion'] = options.client.assertPlugin(plugin);
		}
	};

	/**
	 * Provides handler methods (`assert`, `initialize` and `set`) for controlling for-each-loop behavior
	 * in a sequential workflow, using plugin assertions to determine looping conditions.
	 */
	static foreachLoopHandler = {
		/**
		 * Determines whether the loop should continue by decrementing the index and checking its value.
		 *
		 * This method decrements the `index` stored in `options.data` and returns `true` if the new value
		 * is greater than or equal to zero, indicating that the loop should continue. If the `index` becomes
		 * negative, it returns `false`, signaling the end of the loop.
		 *
		 * @param {Object} options      - The options object containing loop data and step information.
		 * @param {Object} options.data - An object to store loop-related data, including the `index`.
		 *
		 * @returns {boolean} `true` if the loop should continue; otherwise, `false`.
		 *
		 * @example
		 * // Assuming options.data.index is initially 3
		 * const shouldContinue = forLoopHandler.assert(options); // Decrements index to 2, returns true
		 * console.log(options.data.index); // Outputs: 2
		 */
		assert: (options) => {
			// Decrement the 'index' in options.data and check if it's still non-negative
			const canContinue = --options.data[options.step.id]['index'] >= 0;

			// If the index is non-negative, the loop should continue
			if (canContinue) {
				return true;
			}

			// If the loop should not continue, reset the 'onElement' property for each step in the sequence
			for (const index in options.step.sequence) {
				// Retrieve the current step in the sequence
				const step = options.step.sequence[index];

				// Check if the step has an 'onElement' property
				if (step.properties["onElement"]) {
					// Restore the original 'onElement' value
					step.properties["onElement"].value = step.context["originalOnElement"];
				}
			}

			// Return false to indicate the loop should not continue
			return false;
		},

		/**
		 * Initializes the while loop by performing an initial "Assert" step, without returning
		 * the assertion. This sets up the conditions and updates the session for subsequent loop checks.
		 *
		 * 1. Converts the step to a rule using `client.convertToRule`.
		 * 2. Overrides the plugin name to `"Assert"` (necessary when running an "If" step
		 *    in a sequential workflow designer).
		 * 3. Invokes the step via `StateMachine.invokeStep` and waits for the result.
		 * 4. Locates the plugin in the automation result and asserts it, storing that result in `options.data`.
		 *
		 * @async
		 * @function
		 * @name initialize
		 * @memberof whileLoopHandler
		 * @param {Object} options            - The options object used for initializing loop conditions.
		 * @param {Object} options.client     - A reference to the G4 client or automation service client.
		 * @param {Object} options.step       - The current step object being processed.
		 * @param {Object} options.automation - The overall automation object/context.
		 * @param {Object} options.session    - The current session object for tracking state.
		 * @param {Object} options.data       - A generic data object to store/retrieve arbitrary data between steps.
		 *
		 * @returns {Promise<void>} A promise that resolves when initialization is complete.
		 */
		initialize: async (options) => {
			// Store the original locator and onElement values for each step in the sequence
			for (const index in options.step.sequence) {
				const step = options.step.sequence[index];
				step.context = step.context || {};
				step.context["originalOnElement"] = step.properties?.onElement?.value || "";
			}

			// Convert the step to a rule so it can be invoked in the automation engine.
			const rule = options.client.convertToRule(options.step);

			// Override the plugin name to "Assert" for the "If" step. This is necessary to ensure
			// the correct plugin is invoked under the sequential automation specifically for "If" logic.
			rule.pluginName = "Assert";
			rule.argument = "{{$ --Condition:ElementsCount --Expected:0 --Operator:Greater}}";

			// Prepare the options object for invoking the step.
			const invokeOptions = {
				automation: options.automation,
				rule: rule,
				session: options.session,
				step: options.step
			};

			// Invoke the step asynchronously and wait for the result.
			const response = await StateMachine.invokeStep(options.client, invokeOptions);

			// Locate the plugin in the automation result using the step ID.
			const plugin = options.client.findPlugin(options.step.id, response.automationResult);

			// Extract the index from the response and store it in the data object.
			const index = parseInt(plugin.extractions[0].entities[0].content['Actual']);

			// Update the session with any new data from the response.
			options.session = response.session;

			// Initialize the loop index in options.data with the parsed value
			options.data[options.step.id] = options.data[options.step.id] || {};

			// Store the initialized index in options.data for element tracking
			options.data[options.step.id]['total'] = index;

			// Store the initialized index in options.data for loop tracking
			options.data[options.step.id]['index'] = index
		},

		/**
		 * Updates the `onElement` locator in each step of a sequence if the plugin name
		 * is "INVOKEFOREACHLOOP". The function calculates the correct index to use based 
		 * on total vs. current index and updates the locator for XPath or CSS if the 
		 * locator is relative (starts with ".").
		 *
		 * @param {Object} options                 - The options object containing step data and properties.
		 * @param {Object} options.step            - The current step object.
		 * @param {string} options.step.pluginName - Name of the plugin.
		 * @param {Array}  options.step.sequence   - The sequence of steps to be updated.
		 * @param {Object} options.step.properties - The step's property definitions.
		 * @param {Object} options.data            - Data object containing the total and current index.
		 * 
		 * @returns {void}
		 */
		set: (options) => {
			// Only proceed if the current plugin is "INVOKEFOREACHLOOP"
			// Exit early if it's not the correct plugin
			if (options.step.pluginName.toLocaleUpperCase() !== "INVOKEFOREACHLOOP") {
				return;
			}

			// Calculate the index used in the element locator.
			// index = (total steps) - (current step index in the loop)
			const index = options.data[options.step.id]['total'] - options.data[options.step.id]['index'];

			// The base locator is the element defined on the main step (if any)
			const baseLocator = options.step.properties?.onElement?.value;

			// Loop through each step in the sequence and update the locator as necessary
			for (const step of options.step.sequence) {
				// Retrieve the original `onElement` value. If not provided, default to an empty string
				let onElement = step.context?.originalOnElement || "";

				// Determine the locator type (e.g., 'XPATH' or 'CSSSELECTOR'); default to 'XPATH'
				const locator = step.properties?.locator?.value?.toLocaleUpperCase() || "XPATH";

				// Check if onElement starts with '.', indicating a relative reference
				const isSelf = onElement?.startsWith(".");

				// Flags for different locator types
				const isXpath = locator === "XPATH";
				const isCss = locator === "CSSSELECTOR";

				// If the locator is relative and we are using XPATH, construct a new XPATH
				if (isSelf && isXpath) {
					// Example: (//div[contains(@class, "item")])[2]
					onElement = `(${baseLocator})[${index + 1}]`;
				}

				// If the locator is relative and we are using CSS, construct a new CSS selector
				if (isSelf && isCss) {
					// Example: .some-class:nth-of-type(2)
					onElement = `${baseLocator}:nth-of-type(${index + 1})`;
				}

				// If `onElement` is updated, assign it back to the step so it's used in subsequent logic
				if (onElement) {
					step.properties.onElement.value = onElement;
				}
			}
		}
	}

	constructor(definition, handler) {
		this.definition = definition;
		this.speed = definition.properties["speed"];
		this.handler = handler;
		this.data = {};
		this.callstack = [
			{
				sequence: this.definition.sequence,
				index: 0,
				unwind: null
			}
		];
		this.isRunning = false;
	}

	async executeStep(step) {
		await this.handler.executeStep(step, this.data);
	}

	unwindStack() {
		this.callstack.pop();
	}

	async executeIfStep(step) {
		const value = await this.handler.executeIf(step, this.data);
		const branchName = value ? 'true' : 'false';

		this.callstack.push({
			sequence: step.branches[branchName],
			index: 0,
			unwind: this.unwindStack.bind(this)
		});
	}

	executeContainer(container) {
		//this.handler.initStage(stage, this.data);
		this.callstack.push({
			sequence: container.sequence,
			index: 0,
			unwind: this.unwindStack.bind(this)
		});
	}

	/**
	 * Executes the given loop step by initializing the loop state and pushing 
	 * a `program` object onto the call stack. This function handles both 
	 * "INVOKEWHILELOOP" and "INVOKEFOREACHLOOP" scenarios.
	 *
	 * @async
	 * @function invokeLoopStep
	 * @param {Object} step            - The current step object to be executed.
	 * @param {string} step.pluginName - The name of the plugin (e.g. "INVOKEWHILELOOP", "INVOKEFOREACHLOOP").
	 * @param {Array}  step.sequence   - The sequence of steps that belong to this loop.
	 * @returns {Promise<void>}
	 */
	async invokeLoopStep(step) {
		// Initialize loop step data (e.g., set up variables, load resources, etc.)
		await this.handler.initLoopStep(step, this.data);

		// If this is a WHILE loop, determine if the loop is allowed to start
		if (step.pluginName.toLocaleUpperCase() === "INVOKEWHILELOOP") {
			// Check if the loop can start based on the current state
			const canStart = await this.handler.canReplyLoopStep(step, this.data);

			// If the condition fails, do not proceed further
			if (!canStart) {
				return;
			}
		}

		// If this is a FOREACH loop, perform initial loop setup
		if (step.pluginName.toLocaleUpperCase() === "INVOKEFOREACHLOOP") {
			// Calls a handler function to set or update any necessary properties for the loop
			StateMachine.foreachLoopHandler.set({ step, data: this.data });

			// Decrement the loop's current index, allowing the first sequence to be invoked properly
			--this.data[step.id]["index"];
		}

		/**
		 * The `program` object encapsulates the sequence of steps for this loop
		 * and provides an `unwind` method to decide whether to continue or 
		 * exit the loop.
		 */
		const program = {
			// The sequence of steps that belong to this loop
			sequence: step.sequence,

			// Tracks the current position in the sequence of steps
			index: 0,

			/**
			 * If the loop condition is still met, reset the index to replay the sequence.
			 * Otherwise, unwind the call stack to exit the loop.
			 *
			 * @async
			 * @function
			 * @returns {Promise<void>}
			 */
			unwind: async () => {
				// If we are in a FOREACH loop, re-calculate or re-set any loop-specific data
				if (step.pluginName.toLocaleUpperCase() === "INVOKEFOREACHLOOP") {
					StateMachine.foreachLoopHandler.set({ step, data: this.data });
				}

				// Check if the loop can continue
				const canContinue = await this.handler.canReplyLoopStep(step, this.data);
				if (canContinue) {
					// Loop condition is still true; reset index to replay steps
					program.index = 0;
				} else {
					// Loop condition is false; unwind the stack to exit the loop
					this.unwindStack();
				}
			}
		};

		// Push the `program` onto the call stack so it can be executed
		this.callstack.push(program);
	}

	async execute() {
		if (this.isInterrupted) {
			this.handler.onInterrupted();
			return;
		}

		const depth = this.callstack.length - 1;
		const program = this.callstack[depth];

		if (program.sequence.length === program.index) {
			if (depth > 0) {
				await program.unwind();
				this.execute();
			} else {
				this.isRunning = false;
				this.handler?.onFinished(this.data);
			}
			return;
		}

		const step = program.sequence[program.index];
		program.index++;

		if (this.handler.beforeStepExecution) {
			this.handler.beforeStepExecution(step, this.data);
		}

		switch (step.type.toLocaleUpperCase()) {
			case "CONTAINER":
			case "STAGE":
			case "JOB":
				this.executeContainer(step);
				break;
			case 'IF':
				this.executeIfStep(step);
				break;
			case 'LOOP':
				await this.invokeLoopStep(step);
				break;
			default:
				await this.executeStep(step);
				break;
		}

		if (this.handler.onStepExecuted) {
			this.handler.onStepExecuted(step, this.data);
		}
		setTimeout(this.execute.bind(this), this.speed);
	}

	start() {
		if (this.isRunning) {
			throw new Error('Already running');
		}
		this.isRunning = true;
		this.callstack[0].index = 0;
		this.execute();
	}

	interrupt() {
		if (!this.isRunning) {
			throw new Error('Not running');
		}
		this.isInterrupted = true;
	}

	/**
	 * Invokes a specific rule within a given session using automation rules.
	 *
	 * This asynchronous static method performs the following actions:
	 * 1. Converts the provided `step` object into a rule using the `client.convertToRule` method.
	 * 2. Assigns the generated rule to the first job of the first stage in the `automation` configuration.
	 * 3. Sets the driver parameters based on the provided `session`. If `session` is undefined, existing driver parameters are retained.
	 * 4. Invokes the automation process asynchronously using `client.invokeAutomation` and awaits the result.
	 * 5. Extracts the new session identifier from the automation result for further processing.
	 * 6. Returns an object containing the new session identifier and the full automation result.
	 *
	 * @param {Object}  client             - The client instance with `convertToRule` and `invokeAutomation` methods.
	 * @param {Object}  options            - Configuration options for invoking the rule.
	 * @param {string} [options.session]   - The current session identifier. If undefined, existing driver parameters are retained.
	 * @param {Object}  options.step       - The step object to be invoked, containing necessary details for rule conversion.
	   * @param {Object} [options.rule]      - The rule object to be invoked directly, bypassing the conversion from `step`.
	 * @param {Object}  options.automation - The automation configuration object to be modified and used for invocation.
	 *
	 * @returns {Promise<{ session: string, automationResult: Object }>} 
	 *          A promise that resolves to an object containing the new session identifier and the automation result after successfully invoking the rule.
	 *
	 * @throws {Error} Throws an error if the automation invocation fails or if the expected structure is not present in the result.
	 */
	static async invokeStep(client, options) {
		// Convert the provided step object into a rule using the client's utility method.
		const rule = options.rule ? options.rule : client.convertToRule(options.step);

		// Create an array of rules, currently containing only the converted rule.
		const rules = [rule];

		// Assign the generated rules to the first job of the first stage in the automation configuration.
		// Assumes that the automation configuration has at least one stage and one job.
		options.automation.stages[0].jobs[0].rules = rules;

		// Update the driver parameters based on the provided session.
		// If `session` is undefined, retain the existing driver parameters.
		// Otherwise, set the driver to reference the new session ID.
		options.automation.driverParameters = options.session === undefined
			? options.automation.driverParameters
			: { driver: `Id(${options.session})` };

		try {
			// Invoke the automation process asynchronously and wait for the result.
			const automationResult = await client.invokeAutomation(options.automation);

			// Extract the first key from the automation result object.
			// This key typically represents the main response or a specific response type.
			const responseKey = Object.keys(automationResult)[0];

			// Extract the first session ID from the sessions object within the response.
			// This assumes that there is at least one session present in the response.
			options.session = Object.keys(automationResult[responseKey].sessions)[0];

			// Return an object containing the new session ID and the full automation result.
			return {
				session: options.session,
				automationResult
			};
		} catch (error) {
			// Handle any errors that occur during the automation invocation.
			console.error('Automation invocation failed:', error);

			// Rethrow the error after logging to allow further handling upstream.
			throw error;
		}
	}

	/**
	 * Resolves macros within a given automation configuration by invoking the appropriate client method.
	 *
	 * This asynchronous static method performs the following actions:
	 * 1. Converts the provided `step` object into a rule using the `client.convertToRule` method if `options.rule` is not provided.
	 * 2. Assigns the generated or provided rule to the first job of the first stage in the `automation` configuration.
	 * 3. Sets the driver parameters based on the provided `session`. If `session` is undefined, existing driver parameters are retained.
	 * 4. Invokes the macro resolution process asynchronously using `client.resolveMacros` and awaits the result.
	 * 5. Extracts the new session identifier from the automation result for further processing.
	 * 6. Returns the resolved rules after successful invocation.
	 *
	 * @param {Object}  client             - The client instance with `convertToRule` and `resolveMacros` methods.
	 * @param {Object}  options            - Configuration options for resolving macros.
	 * @param {string} [options.session]   - The current session identifier. If undefined, existing driver parameters are retained.
	 * @param {Object}  options.step       - The step object to be invoked, containing necessary details for rule conversion.
	 * @param {Object} [options.rule]      - (Optional) The rule object to be invoked directly, bypassing the conversion from `step`.
	 * @param {Object}  options.automation - The automation configuration object to be modified and used for invocation.
	 *
	 * @returns {Promise<Object>} 
	 *          A promise that resolves to the resolved rules after successfully invoking the macros.
	 *
	 * @throws {Error} Throws an error if the macro resolution invocation fails or if the expected structure is not present in the result.
	 */
	static async resolveMacros(client, options) {
		// Determine whether to use the provided rule or convert the step into a rule using the client's method.
		const rule = options.rule ? options.rule : client.convertToRule(options.step);

		// Create an array of rules, currently containing only the converted or provided rule.
		const rules = [rule];

		// Assign the generated rules to the first job of the first stage in the automation configuration.
		// This assumes that the automation configuration has at least one stage and one job.
		options.automation.stages[0].jobs[0].rules = rules;

		// Update the driver parameters based on the provided session.
		// If `session` is undefined, retain the existing driver parameters.
		// Otherwise, set the driver to reference the new session ID.
		options.automation.driverParameters = options.session === undefined
			? options.automation.driverParameters
			: { driver: `Id(${options.session})` };

		try {
			// Invoke the macro resolution process asynchronously and wait for the result.
			// This method should return the resolved rules after successful invocation.
			return await client.resolveMacros(options.automation);
		} catch (error) {
			// Handle any errors that occur during the macro resolution invocation.
			console.error('Resolution invocation failed:', error);

			// Rethrow the error after logging to allow further handling upstream.
			throw error;
		}
	};
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
class StateMachineSteps {
	static newG4Automation() {
		const authentication = {
			password: CustomFields.newStringField("Password", "The password for the G4 API.", "", true),
			username: CustomFields.newStringField("Username", "The username for the G4 API.", "", true)
		}

		const driverParameters = {

		}

		return {}
	}

	/**
	 * Creates a new Stage container for the G4 Automation Sequence.
	 * 
	 * A Stage is a container that holds Jobs, each comprising specific Actions, to structure and manage the sequential automation flow.
	 * Stages organize tasks into logical groups, enabling efficient execution, resource allocation, monitoring, and error handling within the automation sequence.
	 *
	 * @param {string} name       - The name of the Stage container.
	 * @param {Object} properties - The properties defining the Stage container.
	 * @param {Object} parameters - The parameters associated with the Stage.
	 * @param {Array}  steps      - The steps or actions that belong to the Stage.
	 * @returns {Object} A new Stage container object created by the newG4Container function.
	 */
	static newG4Stage(name, properties, parameters, steps) {
		// Description of the Stage container, detailing its purpose and functionalities within the G4 Automation Sequence.
		const stageDescription = `
        A container that holds jobs, each comprising specific actions, to structure and manage the sequential automation flow.
        Stages organize tasks into logical groups, enabling efficient execution, resource allocation, monitoring, and error handling within the automation sequence.
    `;

		// Initialize the Stage container using the newG4Container function.
		let container = StateMachineSteps.newG4Container(name, 'stage', stageDescription, properties, parameters, steps);
		container["pluginType"] = 'Container'
		container["pluginName"] = 'G4™ Stage'

		// Return the Stage container.
		return container;
	}

	/**
	 * Creates a new Job container within a Stage for the G4 Automation Sequence.
	 *
	 * A Job is a container that holds Actions, organizing and executing them as part of a Job within a Stage.
	 * Job containers manage specific tasks, handle dependencies between actions, coordinate execution,
	 * and ensure efficient resource utilization and error handling within the automation sequence.
	 * By encapsulating related actions, Job containers facilitate modularity, scalability, and maintainability,
	 * allowing complex automation workflows to be broken down into manageable and reusable components.
	 *
	 * @param {string} name       - The name of the Job container.
	 * @param {Object} properties - The properties defining the Job container.
	 * @param {Object} parameters - The parameters associated with the Job.
	 * @param {Array}  steps      - The steps or actions that belong to the Job.
	 * @returns {Object} A new Job container object created by the newG4Container function.
	 */
	static newG4Job(name, properties, parameters, steps) {
		// Description of the Job container, detailing its purpose and functionalities within the G4 Automation Sequence.
		const jobDescription = `
        A container that holds actions, organizing and executing them as part of a job within a stage.
        Job containers manage specific tasks, handle dependencies between actions, coordinate execution,
        and ensure efficient resource utilization and error handling within the automation sequence.
        By encapsulating related actions, job containers facilitate modularity, scalability, and maintainability,
        allowing complex automation workflows to be broken down into manageable and reusable components.
    `;

		// Initialize the Job container using the newG4Container function.
		let container = StateMachineSteps.newG4Container(name, 'job', jobDescription, properties, parameters, steps);
		container["pluginType"] = 'Container'
		container["pluginName"] = 'G4™ Job'

		// Return the Job container.
		return container;
	}

	/**
	 * Creates a new G4 container object for use in a workflow.
	 *
	 * @param {string} name        - The name of the container.
	 * @param {string} type        - The type of the container (e.g., "stage", "job").
	 * @param {string} description - A brief description of the container.
	 * @param {Object} properties  - An object containing properties for the container.
	 * @param {Object} parameters  - An object containing parameters for the container.
	 * @param {Array}  steps       - An array of steps or sub-containers to include in the container's sequence.
	 * @returns {Object} A new container object with a unique ID and specified properties.
	 */
	static newG4Container(name, type, description, properties, parameters, steps) {
		return {
			description: description || 'Description not provided.',
			id: uid(),                    // Generate a unique identifier for the container.
			componentType: 'container',   // Specify the component type as "container".
			type,                         // The type of the container (e.g., stage, job).
			name,                         // The name of the container.
			parameters: parameters || {}, // Parameters specific to the container.
			properties: properties || {}, // Properties specific to the container.
			sequence: steps || []         // The sequence of steps or sub-containers; defaults to an empty array.
		};
	}

	/**
	 * Creates a new G4 step based on the provided manifest.
	 *
	 * @param {Object} manifest - The manifest object containing properties and parameters.
	 * @returns {Object} The newly created G4 step object.
	 */
	static newG4Step(manifest) {
		// Function to convert PascalCase to space-separated words
		const convertPascalToSpaceCase = str => str.replace(/([A-Z])/g, ' $1').trim();

		// Creates a new bridge object from a G4 parameter object.
		const newBridgeObject = (g4ParameterObject) => {
			let bridgeObject = {
				description: g4ParameterObject.description.join('\n'),  // Set summary
				name: convertPascalToSpaceCase(g4ParameterObject.name), // Convert name to space case
				required: g4ParameterObject.mandatory || false,         // Set required flag
				type: g4ParameterObject.type || 'String',               // Set type or default to 'String'
				value: g4ParameterObject.default || '',                 // Set default value or empty string
				optionsList: g4ParameterObject.values || []             // Set options or default to an empty array
			};

			// TODO: Consider to remove this condition
			if (bridgeObject.type.toUpperCase() === 'STRING' || bridgeObject.type.toUpperCase() === 'ANY') {
				bridgeObject.multiLine = false;
			}

			// Return the bridge object
			return bridgeObject;
		}

		// Initialize properties and parameters objects
		const properties = {};
		const parameters = {};

		// Process each property in manifest.properties
		if (manifest.properties) {
			for (const property of manifest.properties) {
				const name = convertToCamelCase(property.name);
				properties[name] = newBridgeObject(property);
			}
		}

		// Process each parameter in manifest.parameters
		if (manifest.parameters) {
			for (const parameter of manifest.parameters) {
				const name = convertToCamelCase(parameter.name);
				parameters[name] = newBridgeObject(parameter);
			}
		}

		// Check if the manifest has categories and determine if it is a condition or loop
		const categories = manifest.categories ? manifest.categories.join("|").toUpperCase() : "";
		let isCondition = categories.includes('CONDITION');
		let isLoop = categories.includes('LOOP');
		let isContainer = !isCondition && !isLoop && (categories.includes('CONTAINER') || manifest.properties.some(item => item.name.toUpperCase() === "RULES"));

		// Initialize the new G4 step object
		let step = {
			componentType: "task",
		};

		// Check if the manifest is a condition and initialize the branches object
		if (isCondition) {
			step.componentType = 'switch';
			step.type = 'if';
			step.branches = {
				true: [],
				false: []
			};
		}

		// Check if the manifest is a loop and initialize the sequence array
		if (isLoop) {
			step.componentType = 'container';
			step.type = 'loop';
			step.sequence = [];
		}

		// Check if the manifest is a loop and initialize the sequence array
		if (isContainer) {
			step.componentType = 'container';
			step.name = "Actions Group";
			step.type = 'container';
			step.sequence = [];
		}

		// Set the remaining properties of the new G4 step object
		step.categories = manifest.categories ? manifest.categories.join("|").toUpperCase() : "";
		step.description = manifest.summary ? manifest.summary.join('\n') : 'Description not provided.';
		step.id = uid();
		step.name = step.name === "Actions Group" ? step.name : convertPascalToSpaceCase(manifest.key);
		step.parameters = parameters;
		step.pluginName = manifest.key;
		step.aliases = manifest.aliases || [];
		step.pluginType = manifest.pluginType;
		step.properties = properties;

		// Return the new G4 step object
		return step;
	}
}

// Client for sending requests to the G4 API.
class G4Client {
	/**
	 * Creates an instance of G4Client.
	 * @param {string} baseUrl - The base URL for the G4 API.
	 */
	constructor(baseUrl = "http://localhost:9944/api/v4/g4") {
		// The base URL for the API.
		this.baseUrl = baseUrl;

		// The URL endpoint to invoke an automation sequence.
		this.invokeUrl = `${this.baseUrl}/automation/invoke`;

		// The URL endpoint to initialize an automation sequence.
		this.initializeUri = `${this.baseUrl}/automation/init`;

		// The URL endpoint to resolve macros in an automation sequence.
		this.macrosUrl = `${this.baseUrl}/automation/resolve`;

		// The URL endpoint to fetch plugin manifests.
		this.manifestsUrl = `${this.baseUrl}/integration/manifests`;

		// The URL endpoint for the cache (if needed for future use).
		this.cacheUrl = `${this.baseUrl}/integration/cache`;

		// An in-memory cache to store fetched manifests.
		this.manifests = [];
	}

	/**
	 * Asserts that all entities within each extraction of the plugin response have a valid 'Evaluation' status.
	 *
	 * This method checks whether every extraction in the provided `pluginResponse` contains entities
	 * where the 'Evaluation' field is either missing or explicitly set to `true`. If any entity has
	 * an 'Evaluation' field set to `false` or any other falsy value, the assertion fails.
	 *
	 * @param {Object} pluginResponse - The response object from the plugin containing extraction data.
	 * @param {Array}  pluginResponse.extractions                      - An array of extraction objects to be validated.
	 * @param {Array}  pluginResponse.extractions[].entities           - An array of entity objects within each extraction.
	 * @param {Object} pluginResponse.extractions[].entities[].content - The content object of each entity, potentially containing an 'Evaluation' field.
	 *
	 * @returns {boolean} Returns `true` if all entities pass the validation criteria, otherwise `false`.
	 *
	 * @throws {TypeError} Throws an error if `pluginResponse` is not an object or if `extractions` is not an array.
	 *
	 * @example
	 * const pluginResponse = {
	 *     extractions: [
	 *         {
	 *             entities: [
	 *                 { content: { name: 'Entity1', Evaluation: true } },
	 *                 { content: { name: 'Entity2' } } // 'Evaluation' is missing, considered true
	 *             ]
	 *         },
	 *         {
	 *             entities: [
	 *                 { content: { name: 'Entity3', Evaluation: true } },
	 *                 { content: { name: 'Entity4', Evaluation: false } } // Evaluation is false
	 *             ]
	 *         }
	 *     ]
	 * };
	 *
	 * const isValid = assertPlugin(pluginResponse);
	 * console.log(isValid); // Output: false
	 */
	assertPlugin(pluginResponse) {
		// Extract the 'extractions' array from the pluginResponse object
		const extractions = pluginResponse.extractions;

		// Ensure that 'extractions' is an array and perform validation
		return extractions.every(extraction =>
			extraction.entities.every(entity => {
				// If the 'Evaluation' field is missing in the entity's content, consider it as true
				if (!('Evaluation' in entity.content)) {
					return true;
				}
				// If the 'Evaluation' field exists, it must be explicitly set to true
				return entity.content["Evaluation"] === true;
			})
		);
	}

	/**
	 * Converts a step object into a rule object for the G4 Automation Sequence.
	 *
	 * This function transforms a given `step` object, which contains plugin information,
	 * properties, and parameters, into a structured `rule` object suitable for use in
	 * the G4 Automation Sequence. It handles the conversion of property keys to camelCase
	 * and formats parameters as command-line arguments.
	 *
	 * @param {Object} step - The step object to convert.
	 * @param {string} step.pluginName - The name of the plugin.
	 * @param {Object} step.properties - An object containing properties for the plugin.
	 * @param {Object} step.parameters - An object containing parameters for the plugin.
	 * @returns {Object} - The converted rule object.
	 *
	 * @example
	 * const step = {
	 *   pluginName: 'SomePlugin',
	 *   properties: {
	 *     'Property One': { value: 'Value1' },
	 *     'Property Two': { value: 'Value2' },
	 *   },
	 *   parameters: {
	 *     'param1': { value: 'value1' },
	 *     'param2': { value: 'value2' },
	 *   }
	 * };
	 *
	 * const rule = convertToRule(step);
	 * console.log(rule);
	 * // Output:
	 * // {
	 * //   "$type": "Action",
	 * //   "pluginName": "SomePlugin",
	 * //   "propertyOne": "Value1",
	 * //   "propertyTwo": "Value2",
	 * //   "argument": "{{$ --param1:value1 --param2:value2}}"
	 * // }
	 */
	convertToRule(step) {
		/**
		 * Converts an array parameter into a formatted string of command-line arguments.
		 *
		 * @param {Object}        parameter         - The parameter object containing the name and value.
		 * @param {string}        parameter.name    - The name of the parameter.
		 * @param {Array<string>} [parameter.value] - An array of values for the parameter.
		 * @returns {string} - A string of formatted command-line arguments. Returns an empty string if the value array is empty.
		 *
		 * @example
		 * const param = { name: 'option', value: ['val1', 'val2'] };
		 * const result = convertFromArray(param);
		 * console.log(result); // "--option:val1 --option:val2"
		 */
		const convertFromArray = (parameter) => {
			// Initialize parameter.value to an empty array if it is undefined or null.
			parameter.value = parameter.value || [];

			// Return an empty string if the value array is empty.
			if (parameter.value.length === 0) {
				return "";
			}

			// Extract the name property from the parameter object.
			const name = parameter.name;

			// Map each item in the value array to a formatted string and join them with spaces.
			return parameter.value.map(item => {
				return `--${name}:${item}`;
			}).join(" ");
		}

		/**
		 * Converts a dictionary parameter into a formatted string of command-line arguments.
		 *
		 * @param {Object} parameter - The parameter object containing the name and value.
		 * @param {string} parameter.name - The name of the parameter.
		 * @param {Object} [parameter.value] - An object representing key-value pairs for the parameter.
		 * @returns {string} - A string of formatted command-line arguments. Returns an empty string if the value object is empty.
		 *
		 * @example
		 * const param = { name: 'config', value: { host: 'localhost', port: '8080' } };
		 * const result = convertFromDictionary(param);
		 * console.log(result); // "--config:host=localhost --config:port=8080"
		 */
		const convertFromDictionary = (parameter) => {
			// Initialize parameter.value to an empty object if it is undefined or null.
			parameter.value = parameter.value || {};

			// Extract the keys from the parameter value object.
			const keys = Object.keys(parameter.value);

			// Return an empty string if the value object has no keys.
			if (keys.length === 0) {
				return "";
			}

			// Extract the name property from the parameter object.
			const name = parameter.name;

			// Map each key-value pair to a formatted string and join them with spaces.
			return keys.map(key => {
				return `--${name}:${key}=${parameter.value[key]}`;
			}).join(" ");
		}

		// Initialize the rule object with the default type and plugin name.
		let rule = {
			"$type": "Action",
			"pluginName": step.pluginName
		};

		// Initialize an array to hold formatted parameter strings.
		let parameters = [];

		/**
		 * Iterate over each property in the step's properties object.
		 * Convert the property key to camelCase and assign its value to the rule object.
		 */
		for (const key in step.properties) {
			// Convert the property key from its original format to camelCase.
			const propertyKey = convertToCamelCase(key);

			// Assign the property's value to the rule object using the camelCase key.
			rule[propertyKey] = step.properties[key].value;
		}

		// Initialize the parameter token as an empty string.
		let parameterToken = '';

		/**
		 * Iterate over each parameter in the step's parameters object.
		 * Format each parameter as "--key:value" and add it to the parameters array.
		 */
		for (const key in step.parameters) {
			// Extract the parameter type from the step's parameters object.
			const parameterType = step.parameters[key].type.toUpperCase();

			// Check if the parameter has a value and is not an empty string.
			const value = step.parameters[key].value;
			const isArray = value && parameterType === 'ARRAY';
			const isDictionary = value && (parameterType === 'DICTIONARY' || parameterType === 'KEY/VALUE' || parameterType === 'OBJECT');
			const isBoolean = parameterType === 'SWITCH';
			const isValue = !isDictionary && !isArray && value && value.length > 0;

			// Construct the parameter token based on the parameter type and value.
			if (isBoolean && isValue) {
				parameterToken = `--${key}`;
			}
			else if (isValue) {
				parameterToken = `--${key}:${value}`;
			}
			else if (isArray) {
				parameterToken = convertFromArray(step.parameters[key]);
			}
			else if (isDictionary) {
				parameterToken = convertFromDictionary(step.parameters[key]);
			}
			else if (!parameterToken || parameterToken === "") {
				continue;
			}
			else {
				continue;
			}

			// Add the formatted parameter token to the parameters array.
			parameters.push(`${parameterToken}`);
		}

		/**
		 * If there are any parameters, concatenate them into a single string
		 * and assign it to the rule's "argument" field in the specified format.
		 */
		if (parameters.length > 0) {
			// The argument field uses a templating syntax with double curly braces.
			rule["argument"] = `{{$ ${parameters.join(" ")}}}`;
		}

		// Normalize rules to avoid bad requests.
		rule.rules = Array.isArray(rule.rules) && rule.rules.length > 0 ? rule.rules : [];

		// Add a reference to the step in the rule object.
		rule.reference = {
			id: step.id
		}

		// Return the fully constructed rule object.
		return rule;
	}

	// TODO: refactor to iterate every parameter and property value and replace them in the original step
	syncStep(step, rule) {
		/**
		 * Parses the argument string (e.g. "{{$ --param1:value1 --param2 --param3:subKey=value3}}")
		 * and returns a structured object describing each parameter with its potential type and values.
		 *
		 * @param {string} arg - The argument string from the rule (e.g. "{{$ --param1:value1 --param2}}").
		 * @returns {Object} An object of parameterName → { type, values }, where `values` holds
		 *                   either booleans, arrays, dictionaries, or single values.
		 *
		 * Example return shape:
		 * {
		 *   param1: { type: 'STRING', values: ['value1'] },
		 *   param2: { type: 'SWITCH', values: [true] },
		 *   param3: { type: 'ARRAY', values: ['val1','val2'] },
		 *   config: { type: 'DICTIONARY', values: [{subKey: 'value'}, {anotherKey: 'anotherVal'}] }
		 * }
		 */
		function formatArgumentString(arg = "") {
			// If there's no argument or it doesn't have the "{{$" prefix, return empty.
			if (!arg.includes("{{$")) {
				return {};
			}

			// Extract the content between "{{$ " and "}}" (remove the templating braces).
			// e.g. "{{$ --param1:value1 --param2}}" -> "--param1:value1 --param2"
			const trimmed = arg.replace("{{$", "").replace("}}", "").trim();

			// Split by space to get each token like ["--param1:value1", "--param2", "--param3:subKey=value3", ...].
			const tokens = trimmed.split(/\s+/);

			// Object that will accumulate data in intermediate form:
			// e.g. {
			//   param1: [ { raw: '--param1:value1', key: 'param1', subKeyValue: 'value1' } ],
			//   param2: [ { raw: '--param2', key: 'param2' } ],
			//   param3: [ { raw: '--param3:subKey=value3', key: 'param3', subKey: 'subKey', subValue: 'value3' } ],
			// }
			const paramMap = {};

			for (const token of tokens) {
				if (!token.startsWith("--")) {
					continue; // skip non-parameter tokens (unlikely but safe).
				}

				// Remove the leading "--"
				const withoutDashes = token.slice(2);

				// Patterns to detect:
				// 1) "param" (boolean switch)        => no colons
				// 2) "param:value" (single/array)    => one colon
				// 3) "param:subKey=value" (dict)     => one colon + '='
				//
				// Let's check if there's a colon.
				const colonIndex = withoutDashes.indexOf(":");
				if (colonIndex === -1) {
					// This is a boolean/switch param, e.g. "--param"
					const paramName = withoutDashes;
					paramMap[paramName] = paramMap[paramName] || [];
					paramMap[paramName].push({ raw: token, key: paramName, isSwitch: true });
					continue;
				}

				// If there's a colon, separate the part before the colon from after it.
				const paramName = withoutDashes.slice(0, colonIndex);
				const remainder = withoutDashes.slice(colonIndex + 1);

				// For dictionary-like tokens, we expect "subKey=value"
				// Check if there's an '=' in remainder
				const eqIndex = remainder.indexOf("=");
				if (eqIndex === -1) {
					// No '=', so it's a single or array param, e.g. "--param:value"
					const paramValue = remainder;
					paramMap[paramName] = paramMap[paramName] || [];
					paramMap[paramName].push({
						raw: token,
						key: paramName,
						value: paramValue
					});
				} else {
					// We have a subKey=value scenario, e.g. "--param:subKey=value"
					const subKey = remainder.slice(0, eqIndex);
					const subValue = remainder.slice(eqIndex + 1);
					paramMap[paramName] = paramMap[paramName] || [];
					paramMap[paramName].push({
						raw: token,
						key: paramName,
						subKey,
						subValue
					});
				}
			}

			// Now we convert `paramMap` into a friendlier shape with inferred parameter types.
			const structuredParams = {};

			for (const [paramName, entries] of Object.entries(paramMap)) {
				// If any entry has "isSwitch" = true, we call it a SWITCH param.
				// (Though it’s possible an advanced user might do something crazy mixing forms, we’ll assume consistency.)
				const isSwitchParam = entries.some(e => e.isSwitch);
				if (isSwitchParam) {
					structuredParams[paramName] = {
						type: "SWITCH",
						// We can store "true" or "on" or something. 
						// Original code used isValue to detect if switch is present. So let's store "true".
						value: "true"
					};
					continue;
				}

				// Check for dictionary style: if all have subKey & subValue, it's dictionary
				const isDictionary = entries.every(e => typeof e.subKey !== "undefined");
				if (isDictionary) {
					// e.g. paramName: [ { subKey: 'host', subValue: 'localhost' }, { subKey: 'port', subValue: '8080' } ]
					const dictObj = {};
					for (const dictEntry of entries) {
						dictObj[dictEntry.subKey] = dictEntry.subValue;
					}
					structuredParams[paramName] = {
						// The original function used "DICTIONARY", "KEY/VALUE", or "OBJECT" interchangeably.
						// We'll pick "DICTIONARY" for consistency.
						type: "DICTIONARY",
						value: dictObj
					};
					continue;
				}

				// Otherwise, check for multiple single values → array
				// If there's more than one entry, or the developer specifically repeated them, treat as array.
				if (entries.length > 1) {
					// e.g. paramName: [ { value: 'val1' }, { value: 'val2' } ]
					structuredParams[paramName] = {
						type: "ARRAY",
						value: entries.map(e => e.value)
					};
					continue;
				}

				// If there's exactly one entry with a "value", it's a single-value (string).
				structuredParams[paramName] = {
					type: "STRING",
					value: entries[0].value
				};
			}

			return structuredParams;
		}

		// Convert each key in rule to a property, skipping known fields.
		const includeKeys = ["argument", "locator", "locatorType", "onAttribute", "onElement", "regularExpression"];
		for (const key in rule) {
			if (!includeKeys.includes(key) || !(key in step.properties)) {
				continue;
			}
			// The remaining keys are assumed to be "property keys" in camelCase form.
			step.properties[key]["resolvedValue"] = rule[key];
		}

		// Parse the argument string back into parameters, if present.
		if (rule.argument) {
			const parsedParams = formatArgumentString(rule.argument);
			for (const [paramName, paramInfo] of Object.entries(parsedParams)) {
				step.parameters[paramName]["resolvedValue"] = paramInfo.value;
			}
		}

		// Return the reconstructed step object.
		return step;
	}

	/**
	 * Searches for a plugin within the provided G4 response model that matches the given reference ID.
	 *
	 * This function traverses the nested structure of the G4 response model, iterating through sessions,
	 * response trees, stages, jobs, and plugins to locate a plugin with a matching reference ID.
	 *
	 * @param {string} referenceId     - The reference ID to search for within the plugins.
	 * @param {Object} g4ResponseModel - The G4 response model object containing nested plugin data.
	 *
	 * @returns {Object|null} The plugin object that matches the reference ID, or null if not found.
	 *
	 * @throws {TypeError} Throws an error if `g4ResponseModel` is not a non-null object or if `referenceId` is not a string.
	 *
	 * @example
	 * const referenceId = 'plugin-12345';
	 * const g4ResponseModel = {
	 *     response1: {
	 *         sessions: {
	 *             session1: {
	 *                 responseTree: {
	 *                     stages: [
	 *                         {
	 *                             jobs: [
	 *                                 {
	 *                                     plugins: [
	 *                                         { performancePoint: { reference: { id: 'plugin-12345' } }, name: 'Plugin A' },
	 *                                         { performancePoint: { reference: { id: 'plugin-67890' } }, name: 'Plugin B' }
	 *                                     ]
	 *                                 }
	 *                             ]
	 *                         }
	 *                     ]
	 *                 }
	 *             }
	 *         }
	 *     }
	 * };
	 *
	 * const foundPlugin = findPlugin(referenceId, g4ResponseModel);
	 * console.log(foundPlugin);
	 * // Output: { performancePoint: { reference: { id: 'plugin-12345' } }, name: 'Plugin A' }
	 */
	findPlugin(referenceId, g4ResponseModel) {
		/**
		 * Generator function to traverse all plugins within the G4 response model.
		 *
		 * Iterates through each response, session, response tree, stage, job, and plugin,
		 * yielding each plugin encountered.
		 *
		 * @param {Object} g4ResponseModel - The G4 response model to traverse.
		 * @yields {Object} Each plugin object found within the response model.
		 */
		function* traversePlugins(g4ResponseModel) {
			// Iterate over each response in the G4 response model
			for (const response of Object.values(g4ResponseModel)) {
				// Extract the sessions object from the current response
				const sessions = response.sessions;

				// Continue to the next response if sessions is not an object
				if (!sessions || typeof sessions !== 'object') continue;

				// Iterate over each session within the current response
				for (const session of Object.values(sessions)) {
					// Extract the response tree object from the current session
					const responseTree = session.responseTree;

					// Continue to the next session if responseTree is not an object
					if (!responseTree || typeof responseTree !== 'object') continue;

					const stages = responseTree.stages;
					// Continue to the next session if stages is not an array
					if (!Array.isArray(stages)) continue;

					// Iterate over each stage within the response tree
					for (const stage of stages) {
						// Extract the jobs array from the current stage
						const jobs = stage.jobs;

						// Continue to the next stage if jobs is not an array
						if (!Array.isArray(jobs)) continue;

						// Iterate over each job within the current stage
						for (const job of jobs) {
							// Extract the plugins array from the current job
							const plugins = job.plugins;

							// Continue to the next job if plugins is not an array
							if (!Array.isArray(plugins)) continue;

							// Iterate over each plugin within the current job and yield it
							for (const plugin of plugins) {
								yield plugin;
							}
						}
					}
				}
			}
		}

		// Input validation to ensure `g4ResponseModel` is a non-null object
		if (typeof g4ResponseModel !== 'object' || g4ResponseModel === null) {
			throw new TypeError('g4ResponseModel must be a non-null object');
		}

		// Input validation to ensure `referenceId` is a string
		if (typeof referenceId !== 'string') {
			throw new TypeError('referenceId must be a string');
		}

		// Traverse through all plugins and search for the one with the matching reference ID
		for (const plugin of traversePlugins(g4ResponseModel)) {

			// Check if the plugin's performancePoint.reference.id matches the referenceId
			// Return the matching plugin
			if (plugin.performancePoint?.reference?.id === referenceId) {
				return plugin;
			}
		}

		// Return null if no matching plugin is found
		return null;
	}

	/**
	 * Fetches the G4 cache from the API.
	 *
	 * @async
	 * @returns {Promise<Object>} A promise that resolves to the cached data retrieved from the API.
	 * @throws {Error} Throws an error if the network request fails or the response is not OK.
	 */
	async getCache() {
		try {
			// Fetch the cache data from the API using the cacheUrl endpoint.
			const response = await fetch(this.cacheUrl);

			// Check if the response status indicates success (HTTP 200-299).
			if (!response.ok) {
				throw new Error(`Network response was not ok: ${response.statusText}`);
			}

			// Parse the JSON data from the response.
			const data = await response.json();

			// Return the parsed cache data.
			return data;
		} catch (error) {
			// Log the error to the console for debugging.
			console.error('Failed to fetch G4 cache:', error);

			// Rethrow the error to ensure the caller is aware of the failure.
			throw new Error(error);
		}
	}

	/**
	 * Retrieves and organizes plugin manifests into groups based on their categories and scopes.
	 *
	 * @async
	 * @returns {Promise<Object>} A promise that resolves to an object containing grouped manifests.
	 * Each group is keyed by category (and optionally scope) with its corresponding manifests.
	 */
	async getGroups() {
		// Function to convert PascalCase to space-separated words.
		const convertPascalToSpaceCase = (str) => str.replace(/([A-Z])/g, ' $1').trim();

		// Fetch the manifests using the existing method.
		const manifests = await this.getManifests();

		// Initialize an empty object to store the groups.
		const groups = {};

		// Iterate through each manifest in the manifests object.
		for (const manifest of Object.values(manifests)) {
			// Ensure the manifest has a 'scopes' array.
			manifest.scopes = manifest.scopes || [];

			// Determine if the manifest has a scope that includes 'ANY' (case-insensitive).
			const isAnyScope = manifest.scopes.some(scope => scope.toUpperCase() === 'ANY') || manifest.scopes.length === 0;

			// Retrieve the categories array or use an empty array if it's undefined.
			const categories = manifest.categories || [];

			// If the manifest has 'ANY' scope, add it to each of its categories.
			if (isAnyScope) {
				for (const category of categories) {
					// Convert the category name to a space-separated string.
					const categoryName = convertPascalToSpaceCase(category);

					// Ensure the group exists for this category.
					groups[categoryName] = groups[categoryName] || { name: categoryName, manifests: [] };

					// Add the manifest to the category's group.
					groups[categoryName].manifests.push(manifest);
				}

				// Skip processing other scopes since 'ANY' covers all.
				continue;
			}

			// If no 'ANY' scope, iterate through each category and scope.
			for (const category of categories) {
				for (const scope of manifest.scopes) {
					// Create a combined category name (e.g., "Category (Scope)").
					const categoryName = `${convertPascalToSpaceCase(category)} (${convertPascalToSpaceCase(scope)})`;

					// Ensure the group exists for this combined category and scope.
					groups[categoryName] = groups[categoryName] || { name: categoryName, manifests: [] };

					// Add the manifest to the combined group's manifests.
					groups[categoryName].manifests.push(manifest);
				}
			}
		}

		// Return the organized groups.
		return groups;
	}

	/**
	 * Fetches and returns G4 manifests of type 'Action'.
	 * Caches the manifests after the first fetch to avoid redundant network requests.
	 * 
	 * @returns {Promise<Object>} A promise that resolves to the manifests object.
	 * @throws Will throw an error if the network request fails.
	 */
	async getManifests() {
		// If manifests are already cached, return them directly.
		if (this.manifests.length > 0) {
			return this.manifests;
		}

		try {
			// Fetch the plugin manifests from the API.
			const response = await fetch(this.manifestsUrl);

			// Check if the response status is OK (HTTP 200-299).
			if (!response.ok) {
				throw new Error(`Network response was not ok: ${response.statusText}`);
			}

			// Parse the JSON response.
			const data = await response.json();

			// Filter only the plugins of type 'Action' and organize them into a dictionary by `key`.
			this.manifests = data
				.filter(item => item.pluginType === 'Action') // Include only 'Action' type plugins.
				.reduce((cache, manifest) => {
					// Use the `key` field of the manifest as the dictionary key.
					cache[manifest.key] = manifest;
					return cache;
				}, {});

			return this.manifests; // Return the cached manifests.
		} catch (error) {
			// Log the error for debugging and rethrow it.
			console.error('Failed to fetch G4 plugins:', error);
			throw new Error(error);
		}
	}

	/**
	 * Invokes the G4 Automation Sequence by sending a POST request with the provided definition.
	 *
	 * This asynchronous function sends a JSON payload to a predefined automation URL using the Fetch API.
	 * It handles the response by parsing the returned JSON data and managing errors that may occur during the request.
	 *
	 * @async
	 * @function invokeAutomation
	 * 
	 * @param    {Object} definition - The automation definition object to be sent in the POST request body.
	 * 
	 * @returns  {Promise<Object>} - A promise that resolves to the parsed JSON response data from the server.
	 * 
	 * @throws   {Error} - Throws an error if the network response is not ok or if the fetch operation fails.
	 */
	async invokeAutomation(definition) {
		try {
			// Invoke the G4 automation sequence by sending a POST request with the automation definition.
			const response = await fetch(this.invokeUrl, {
				method: 'POST', // HTTP method set to POST for sending data
				headers: {
					'Content-Type': 'application/json' // Indicates that the request body is in JSON format
				},
				body: JSON.stringify(definition) // Converts the definition object to a JSON string for the request body
			});

			// Check if the response status indicates a successful request (HTTP status code 200-299).
			if (!response.ok) {
				// If the response is not ok, throw an error with the status text for debugging purposes.
				throw new Error(`Network response was not ok: ${response.statusText}`);
			}

			// Parse the JSON data from the successful response.
			const data = await response.json();

			// Return the parsed data for further processing by the caller.
			return data;
		} catch (error) {
			// Log the error to the console for debugging and monitoring purposes.
			console.error('Failed to invoke G4 automation:', error);

			// Rethrow the original error to ensure that the caller can handle it appropriately.
			// Using 'throw error' preserves the original error stack and message.
			throw error;
		}
	}

	/**
	 * Resolves all macros for the G4 Automation Sequence by sending a POST request with the provided definition.
	 *
	 * This asynchronous function sends a JSON payload to a predefined automation URL using the Fetch API.
	 * It handles the response by parsing the returned JSON data and managing errors that may occur during the request.
	 *
	 * @async
	 * @function invokeAutomation
	 * 
	 * @param    {Object} definition - The automation definition object to be sent in the POST request body.
	 * 
	 * @returns  {Promise<Object>} - A promise that resolves to the parsed JSON response data from the server.
	 * 
	 * @throws   {Error} - Throws an error if the network response is not ok or if the fetch operation fails.
	 */
	async resolveMacros(definition) {
		try {
			// Resolve the G4 automation sequence by sending a POST request with the automation definition.
			const response = await fetch(this.macrosUrl, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify(definition)
			});

			// Check if the response status indicates a successful request (HTTP status code 200-299).
			// If the response is not ok, throw an error with the status text for debugging purposes.
			if (!response.ok) {
				throw new Error(`Network response was not ok: ${response.statusText}`);
			}

			// Parse the JSON data from the successful response.
			const data = await response.json();

			// Return the parsed data for further processing by the caller.
			return data;
		} catch (error) {
			// Log the error to the console for debugging and monitoring purposes.
			console.error('Failed to resolve G4 automation:', error);

			// Rethrow the original error to ensure that the caller can handle it appropriately.
			// Using 'throw error' preserves the original error stack and message.
			throw error;
		}
	}

	newAutomation(authentication, driverParameters) {
		driverParameters = driverParameters || {
			"driver": "MicrosoftEdgeDriver",
			//"driverBinaries": "https://gravityapi1:pyhBifB6z1YxJv53xLip@hub-cloud.browserstack.com/wd/hub",
			"driverBinaries": "E:\\Binaries\\Automation\\WebDrivers",
			"capabilities": {
				"alwaysMatch": {
					"browserName": "MicrosoftEdge"
				},
				"firstMatch": [
					{}
				]
			}
		};
		authentication = authentication || {
			username: "pyhBifB6z1YxJv53xLip",
			password: ""
		};

		return {
			authentication,
			driverParameters,
			stages: [
				{
					description: "Main Stage",
					jobs: [
						{
							description: "Main Stage",
							name: "Main Stage",
							rules: [
							]
						}
					],
					name: "Main Stage"
				}
			]
		};
	}
}
